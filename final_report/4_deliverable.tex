\chapter{Deliverables}
\label{chap:Deliverable}

This chapter will go through the work that was produced as a result of this
project. We will take a look at the website, examples of code for both frameworks,
and how we tested both frameworks. After describing the websites and both frameworks,
we will discuss the experiments that we ran on our websites, and evaluate
the performance of each framework.

\section{The Website - Wire}

Most of the features that we planned for were implemented in the final version
of the website. The website was named `Wire' and users can create an account,
post messages, follow other users, see user messages, post tagged
messages, and search for other messages and users. The following subsections
contain pictures of the website produced. The pictures taken are of the Yesod
website but the Django site is functionally identical, with only a few minor styling
differences.

\subsection{The Home Page}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{final_report/pics/home.png}
	\caption{The home page}
	\label{fig:wireHome}
\end{figure}

The home page is the first page the user sees when they access the website.
The home page contains the latest messages posted by users on the website,
with a separate list for tagged messages. Messages that contain tags are links
that take the user to the search page. There is a navigation bar at the top of
the home page. This navigation bar is present on all pages. When a user is not
logged in, the navigation bar allows the user to access the login and signup pages.
Once logged in, the user can use the navigation bar to access their profile page
or to logout.

\subsection{Authentication}

The authentication functionality of this website includes signing up and
logging in using a web page, and logging out using a button in the navigation
bar. Signing up requires
a username, e-mail, and password. The username and e-mail must be unique.
Users are shown a warning message if they try to sign up with details that
are already taken. Once a user signs up, their details are stored in the
database, with the password being hashed and salted to ensure that it is
stored safely.

When logging in, you only need to supply a username and password.
This is because the username is a unique
identifier, we can use it to determine which user to log in as. When the username
and password is submitted, we look up the username in the database, encrypt the
password, and see if the encrypted password matches the one stored in the database. 
If there is a match, the user is authenticated and redirected to the home page. 
If there is an issue, the user is redirected back to the login page with an 
appropriate error messages.

Once the user is logged in, they can use the log out button which is present
on the top right of the navigation bar. Clicking this button immediately logs
the user out and they are redirected to the home page.

\subsection{User Profiles}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{final_report/pics/profile.png}
	\caption{The profile page for the current user}
	\label{fig:wireProfile}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{final_report/pics/otherProfile.png}
	\caption{The profile page for other users}
	\label{fig:wireOtherProfile}
\end{figure}

The profile pages are probably the most complex with regards to logic in the
entire website. There are two different profile pages, one for the currently
logged in user which only they can see, and another for when someone is
viewing the profile page of another user.

Figure ~\ref{fig:wireProfile} is what a logged in user sees if they visit
their own profile page. On this page, they can see a list of messages posted
by users that they follow, see which users are following them, follow and
unfollow other users, and post their own messages. They can also post a
new message by clicking on the `New Wire' button. Clicking this button
displays a form with an input box for the user to enter their message.

Figure ~\ref{fig:wireOtherProfile} is what the profile page looks like
when a user navigates to another person's profile page, or when they click
the `See how your profile page looks like to others' link on their own
profile page. This page shows the name of the person who owns the page,
the users they follow, other users that follow them, and messages that
they have posted.

One feature to note is that the messages and other user information on
the profile page is loaded in via AJAX. This ensures that the initial
page load is quick, following and unfollowing users does not necessitate
an entire page reload, and makes it easier to, if desired, add a feature
to automatically update the message area.

\subsection{The Search Page}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{final_report/pics/searchBase.png}
	\caption{The search page}
	\label{fig:wireSearch}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{final_report/pics/searchWire.png}
	\caption{The search results page for messages}
	\label{fig:wireSearchWire}
\end{figure}

Figure ~\ref{fig:wireSearch} is the page that the user is navigated to when they
click the search button in the navigation bar. In this page, they can type in
their search query and use the dropdown to specify whether they are searching
for users or messages. Once they submit their query, they are redirected to
the search results page, as seen in Figure ~\ref{fig:wireSearchWire}.

\section{The Yesod Implementation}

In this section, we will briefly discuss how the website was implemented in Yesod.
We will take a look at creating database entities, URL routing, handling requests,
creating templates, and writing tests.

\subsection{The Scaffold}

When creating a new Yesod site, it is recommended to use the scaffolding tool.
The scaffolding tool generates code that sets up the structure of your project. It
creates the files needed to connect to a database and launch a website. Sample code
is included for developers to see how the framework works. By running the scaffolding
tool, it is clear to the developer where source files, configuration settings, templates, and 
static files should be kept. \parencite[Scaffolding and the Site Template]{yesodBook}

The Yesod codebase used for this project was built on top of code generated by the
scaffolding tool using the yesod-postgres template, which tells the generated code
to be compatible with a PostgreSQL database.

\subsection{An Overview}

Figure ~\ref{fig:yesodOverview} gives you a high level overview of how Yesod
dispatches a request. By dispatch, we mean taking an incoming request and
then generating an appropriate response \parencite[Understanding a Request]{yesodBook}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{final_report/pics/yesod_diagram.png}
	\caption{An overview of Yesod, from the Request to the Response}
	\label{fig:yesodOverview}
\end{figure}

In the figure above, you can see that all requests go to the \texttt{config/routes}
file. This file is used to specify valid routes in an application, and will
forward all requests to an appropriate Handler. \parencite[Understanding a Request]{yesodBook}

A Handler is a more general term for a web application. Handlers are Haskell
files stored in the \texttt{src/} directory. These handlers are used to interact
with database entities, load an appropriate template file, and then send
a response to the user. \parencite[Understanding a Request]{yesodBook}

The models file located in \texttt{config/models} specifies all the database
entities in this web application. Each entry in this file generates a database
table and also creates helper functions for you to use in your Haskell code.
The handlers normally interact with these entities to deal with certain requests.
For example, if the user wants to log in to a website, the request will go to the
\texttt{Login} handler, which will check if the credentials provided by the user
is correct, and then generate an appropriate response.

When a Handler needs to response with a HTML page, a template file is
normally used. A template file is a file with syntax similar to HTML
that defines the content of a HTML page.

\subsection{Defining Routes}

As explained previously, URL routes are available routes in an application and are specified in the 
\texttt{config/routes} file. In this file, you specify whether a request from a route is a
GET or POST request, the handler that deals with the request, and any parameters
that are part of the request. One of the features of Yesod is type safety in URLs,
so you can specify the actual type that a URL parameter should be. If the user
tries to navigate to a page with an invalid parameter, a 404 page will be shown.
An extract from the `config/routes' file can be seen in code block 
~\ref{code:yesodRoutes} below.

\lstset{language={Haskell}}

\begin{lstlisting}[caption={Yesod URL routes},label={code:yesodRoutes}]
	-- This code block is an extract of the routes file. Each route is split into
	-- three parts. The first part is the actual URL route that the user will
	-- type. This route can contain a parameter which is mapped to a value from the URL.
	-- The second part specifies a Haskell module that will deal with a request
	-- from the given URL. The third part specifies the request types valid at this URL.
	/profile MyProfileR GET POST
	/profile/#Text ProfileR GET
	
	/user UserGetAllR GET
	/user-not-following UserGetAllExcludingFollowingR GET
	/user/#Text UserGetAllExcludingUsernameR GET
	/user/id/#UserId UserGetIdR GET
	/users/*[UserId] UserGetIdsR GET
\end{lstlisting}

In code block ~\ref{code:yesodRoutes}, you can see that there
are two routes for the profile page. One, \texttt{/profile}, is for users
viewing their own profile page and the other, \texttt{/profile/\#Text}, is
for viewing the profile page of another user. The \texttt{\#Text} part
of the route specifies that there should be one parameter for this
route with the type \texttt{Text}. If multiple parameters are provided or a parameter
is not of the type \texttt{Text}, a 404 error is shown.

Further examples of URL parameters can be seen in the \texttt{user} routes. 
\texttt{/user/id/\#UserId} expects a user id as a parameter. If the specified
id is not found, a 404 page is shown. \texttt{/users/\*[UserId]} expects a list
of user ids, which would look like \texttt{/users/1/2/3/4/}.

\subsection{Database Entities}

Database entities are defined in the \texttt{config/model} file. In this file, you
give a name to the entity you want to create, the names and types of it's
fields, functions that the entity and it's fields should include, and
any fields that are unique, i.e. Cannot be shared with other entities.
Once an entity is added to this file, it is created in the database
when the codebase is compiled and helper functions are created that
can be used when programming. Code block ~\ref{code:yesodEntities} contains
the definition of the user entity extracted from the `config/models' file.

\begin{lstlisting}[caption={Yesod Database Entities},label={code:yesodEntities}]
	User json key -- Specify the name of the entity and some helper functions
		username Text Eq -- Specify entity fields and their types
		email    Text Eq
		password Text
		UniqueUser username
		UniqueEmail email
		deriving Typeable Show -- Some Haskell helper functions
\end{lstlisting}

\subsection{Handlers}

Every URL route in the application points to a handler.
Handlers are used to perform any calculations or queries 
that need to be done and then respond to a request by rendering a template file, 
returning a JSON object, or by redirecting to another handler.

Code block ~\ref{code:yesodGetProfileR} is the handler used to respond to get requests
to display the profile page of the current user. The handler ensures the user is logged in,
loads the user's details,
and then loads the template file. The variables that are available
in the handler are also available in the template file.

\lstset{language={Haskell}}

\begin{lstlisting}[caption={GET request handler for current profile page},label={code:yesodGetProfileR}]
	-- Loads the 'My Profile' page for the currently logged in user. If someone
	-- who is not logged in attempts to access the page, a 404 error will be shown.
	getMyProfileR :: Handler Html -- This function will respond to GET requests to the profile page
	getMyProfileR = do
		(Entity userId user) <- requireAuth -- Get the current user's data from the database
		let username = userUsername user -- Extract username from the user
	
		-- Here, we generate a Haskell form to be used in a template file
		(formWidget, formEnctype) <- generateFormPost $ messageForm userId
		defaultLayout $ do -- Load the default layout that wraps around the loaded template
			setTitle . toHtml $ userUsername user -- Set the title of the profile page
			$(widgetFile "currentprofile") -- Load a template file
\end{lstlisting}

You may have noticed the message form being generated in code block ~\ref{code:yesodGetProfileR}.
This form is defined in Haskell and the source code can be seen in code block ~\ref{code:yesodMessageForm}.
When defining the form, we give it a user id to specify the user creating a message. 
We tell the form that there is one input field that is required. Two hidden fields
are also included to ensure the form has all the data needed to create a message.

\clearpage 
\begin{lstlisting}[caption={The message form},label={code:yesodMessageForm}]
	-- Here, we create a Bootstrap3 form for the Message entity
	messageForm :: UserId -> Form Message
	messageForm userId = renderBootstrap3 BootstrapBasicForm $ Message
		<$> areq textField (bfs ("Message" :: Text)) Nothing -- A required text field
		<*> pure userId -- A hidden field containing the userId
		<*> lift (liftIO getCurrentTime) -- A hidden field containing the current time
\end{lstlisting}

When the user submits the form, the post handler is ran, which can be seen in code block
~\ref{code:yesodPostProfileR}. In this handler, we use the function \texttt{runFormPost}
to check whether or not the form is valid. If the form is valid, the message is added
to the database and the profile page is reloaded with a success message. If there's an
issue with the form, the profile page is reloaded with an appropriate error message.

\begin{lstlisting}[caption={POST request handler for current profile page},label={code:yesodPostProfileR}]
	-- Create a new wire for the logged in user
	postMyProfileR :: Handler Html
	postMyProfileR = do
		(Entity userId _) <- requireAuth
		((result, _), _) <- runFormPost $ messageForm userId -- Get the message form from the post request
		case result of -- Check whether or not the message form is valid
			FormSuccess message -> do
				_ <- runDB . insert $ message -- Insert the message typed in by the user
				setSession "msgrendered" "true"
				setMessage $ renderSuccessMessage "Wire Sent" -- Set a message to be shown to the user
				redirect MyProfileR -- Reload the profile page
			FormFailure errors -> do
				let renderedMessages = map renderErrorMessage errors -- Collect all the error messages
				setSession "msgrendered" "true"
				setMessage $ toHtml renderedMessages -- Set the error messages to be shown to the user
				redirect MyProfileR
			FormMissing -> do
				setSession "msgrendered" "true"
				setMessage $ renderErrorMessage "Form is missing"
				redirect MyProfileR
\end{lstlisting}

If a route contains a URL parameter, the handler must also have a parameter to store
the value of the given parameter. Code block ~\ref{code:yesodGetUserGetIdR} is the
source code for a handler that takes in a user id as a parameter. As you can see,
we do not have to check for the type of this parameter or whether it is not null.
We specified the type of the URL parameter in the routes file (code block ~\ref{code:yesodRoutes})
so Yesod will perform type checking for us, saving developers time from having
to manually deal with invalid types or values.

\clearpage

\begin{lstlisting}[caption={GET request handler for getting user data},label={code:yesodGetUserGetIdR}]
	-- | Takes in a user id and returns data on the user matching the given id.
	-- If no user is found, an empty JSON object is returned.
	getUserGetIdR :: UserId -> Handler Value
	getUserGetIdR userId = do -- Here, userId is a parameter from the URL
		users <- runDB $ selectList [UserId ==. userId] [] -- Load the user with the given user id from the database
		-- The map in the line below extracts the username from the user object and
		-- stores this in a new object called cleanUsers. This ensures that the
		-- user's email and (hashed) password is not given in the response. 
		let cleanUsers = map (\(Entity uid (User uname _ _)) -> (object ["id" .= uid, "username" .= uname])) users
		returnJson cleanUsers
\end{lstlisting}

\subsection{Templates}

The templates used in Yesod are called Shakespearean templates. Shakespearean templates
allow you to write type-safe templates that are compiled, helping prevent runtime errors.
The syntax for Shakespearean templates are similar to the languages they are based on,
with minor syntax changes. For example, the HTML template language, Hamlet,
uses indentation rather than opening and closing tags to denote nesting. Within these
templates, you can use Haskell variables, create type-safe routes, and implement conditional
and looping logic. \parencite[Shakespearean Templates]{yesodBook}

When a template file is loaded in a handler, the file is actually included inside
a default file. The default file contains content that is common to all pages. This
ensures that code does not need to be repeated, reducing the chance of mistakes and
making it easier to change the layout of the whole site.

A simple template file can be seen in code block ~\ref{code:yesodSearchHamlet}. In this
block, you can see how indentation is used to determine nesting. Variable interpolation
is done using \texttt{\#\{variableName\}}. You can see the form is being loaded using
\texttt{\string^\{widgetName\}}, which renders the given widget onto the page. Type safe
URLs are loaded using \texttt{\string@\{routeName optionalParameters\}}.

\begin{lstlisting}[caption={Template file for the search page},label={code:yesodSearchHamlet}]
	<main>
		<div .container>
			<div .row>
				<div .col-sm-12>
					<form #search-form .inline .form-horizontal role=form method=post action=@{SearchR} enctype=#{formEnctype}>
						^{formWidget}

\end{lstlisting}

\subsection{Tests}
The Yesod test suite allows you to create BDD-style tests. When creating a test,
you specify what it should do, create any database entities you need, make a
request to a handler, and examine the response to see if the data you received
is correct. Code block ~\ref{code:yesodGetProfileTest} is an actual test
from the website. The test creates and logs in as a new user, loads
the profile page, and ensures that the resulting HTML contains the text that
it should contain. Yesod gives you the ability to use CSS selectors when checking
the HTML page given by a response, allowing you to be very specific.

\begin{lstlisting}[caption={Test the profile page},label={code:yesodGetProfileTest}]
	it "asserts that the current profile page looks right" $ do
		foo <- createUser "foo" "foo@bar.com" "foo"
		authenticateAs foo

		get MyProfileR
		htmlAnyContain "h3" "Your Page"
		htmlAnyContain "h3" "Your Feed"
		htmlAnyContain "h3" "Followers"
		htmlAnyContain "h3" "Following"
		htmlAnyContain "h3" "Other Users"
\end{lstlisting}

The testing suite also has the ability to check if a JSON response contains the
data that we expect. However, you do not have the same helper functions available
to you when compared to checking HTML responses. When checking JSON response, you
must examine the body of the response itself. You cannot check if a JSON key has
a given value. See code block ~\ref{code:yesodGetAllUsers} below.

\begin{lstlisting}[caption={Checking a JSON response},label={code:yesodGetAllUsers}]
	it "asserts all users are returned when not authenticated" $ do
		_ <- createUser "foo" "foo@bar.com" "foo"
		_ <- createUser "bar" "bar@bar.com" "foo"
		_ <- createUser "baz" "baz@bar.com" "foo"

		get UserGetAllR

		bodyContains "username"
		bodyContains "id"
		bodyNotContains "email"
		bodyNotContains "password"
		bodyContains "foo"
		bodyContains "bar"
		bodyContains "baz"
\end{lstlisting}

\section{The Django Implementation}
Now, we will discuss how the Django site was implemented. We will go through Django apps,
routes, entities, views, templates, and tests.

\subsection{Creating a Project}
All Django sites require a Django project. A project is
a directory that contains all the settings needed for a Django website. This includes
database settings, the apps being used, application settings, and Django-specific
settings. To create the project, the \texttt{django-admin} tool was used. This tool
generates the code needed to connect to a database and start a Django site. \parencite{djangoIntroDocs}

\subsection{Creating Apps}

The code used for the actual web application resides in two Django apps, \texttt{base} and
\texttt{wire\_profile}. In Django, an app is a web application that can be a part of a project.
These apps contain the URL routes used in the application, database entities, views
that respond to requests, templates, and tests. The \texttt{manage.py} tool provided
by Django was used to create apps. This tool creates a directory with a specified name
and a layout of files and directories that is preferred for Django apps. \parencite{djangoIntroDocs}

\subsection{An Overview}

This subsection will give you a high level overview of how Django works. 
Figure ~\ref{fig:djangoOverview} shows you how Django generates a response
from a user's request. In the diagram, you can see that all requests first
go to the \texttt{urls.py} file. In this file, a request is matched with
an entry in the file, and this entry forwards the response to an appropriate
view.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{final_report/pics/django_diagram.png}
	\caption{An overview of Django, from the Request to the Response}
	\label{fig:djangoOverview}
\end{figure}

A view is python function that takes in a request and generates an appropriate
response. A valid response could be a HTML page, an HTML error, JSON data, etc.
To generate an appropriate response, a view may interact with a model, or it
may need to load a template file. Views are defined in the \texttt{views.py}
file. \parencite{djangoViews}.

Models, located in \texttt{models.py} are used to define database entities
in an application. Each entry is written as a class and is mapped to a table
in the database. Views interact with these models to read or write data
to the database.

Template files are simply files written in HTML that define the content
of a page. Views use template files to render an appropriate response if
the response is a HTML page.

\subsection{Routes}

Django routes are specified in the \texttt{urls.py} file within an app. The routes
specify a URL path, a view that responds to requests from the given path, and a name
that is used to refer to a route within code. Django routes can contain URL parameters,
like Yesod. The valid values for these parameters can be defined using regular expressions
or a few built in types like \texttt{string} or \texttt{int}. To denote a list of parameters,
\texttt{<path:parameterName>} can be used. An example of Django routes can be seen in code block ~\ref{code:djangoRoutes}.

\lstset{language={Python}}

\begin{lstlisting}[caption={An extract of Django routes},label={code:djangoRoutes}]
	# The path function below takes in three variables. The first
	# variable is the URL path for the request, the second parameter
	# links to a view that will handle a request, and the third
	# parameter is the name for the route that can be used in Python code
	path('following/<path:username>', views.get_following, name='get_following'),
	path('users/<path:user_ids>', views.get_user_ids, name='get_user_ids'),
	path('user/id/<int:user_id>', views.get_user_id, name='get_user_id'),
	path('search', SearchView.as_view(), name='search'),
\end{lstlisting}

\subsection{Database Entities}

Database entities are defined as classes in the \texttt{models.py} file within an app.
The variables inside
each class are used to determine the names and types of entity's fields. You can see
an example of a Django model in ~\ref{code:djangoEntities}. When an entity is created 
or modified, Django migrations must be created and then ran using the \texttt{manage.py} tool. 
Migrations are used by Django to ensure changes you make to models are executed in 
the database schema. \parencite{djangoMigrations}.

\begin{lstlisting}[caption={The user entity in Django},label={code:djangoEntities}]
	class Message(models.Model):
		message_text = models.CharField(max_length=280)
		created = models.DateTimeField('created')
		user = models.ForeignKey(User, on_delete=models.CASCADE)

		def __str__(self):
			return self.message_text
\end{lstlisting}

\subsection{Views}

Views in Django are similar to Handlers in Yesod, they are used to create
a response for a given request. There are two main types of views that you can
create in Django, class-based views and function-based views. The Django website
produced contains a mixture of class-based and function-based views.

Code block ~\ref{code:djangoCurrentProfileView} is a class-based view used to
render the profile page for the current user. In this view, we check if the
user is authenticated and then render the profile page for the authenticated
user. If the user is not authenticated, we redirect them to the home page and
show an error message.

\begin{lstlisting}[caption={Class-based current profile view},label={code:djangoCurrentProfileView}]
	class CurrentProfileView(TemplateView):
		template_name = "wire_profile/current_profile.html"

		def get(self, request, *args, **kwargs):
			"""
			Get the current profile if the user is logged in.

			:param request: The current request
			:param args: sent to parent method
			:param kwargs: sent to parent method
			:return: Either redirect to the search page or render the profile page
			"""
			if request.user.is_authenticated:
				context = self.get_context_data(**kwargs) # context is a map of objects that can be used in the template
				form = NewWireForm()
				context['form'] = form
				context['user'] = request.user
				return self.render_to_response(context)
			else:
				messages.error(request, 'You must log in to view your profile page', extra_tags='danger')
				return HttpResponseRedirect(reverse('base:home'))
\end{lstlisting}

In the current profile view, we load a Django form for a user to create a message,
just like we do in Yesod. This form is located in the \texttt{forms.py} file. The
form, as seen in code block ~\ref{code:djangoMessageForm}, is a class where variables map
to input names. The Django form only requires one field, the message. No hidden
fields are used to determine the user that created a message, this is done in
the view itself.

\begin{lstlisting}[caption={Django message form},label={code:djangoMessageForm}]
	class NewWireForm(forms.Form):
		message = forms.CharField(widget=forms.Textarea(attrs={'rows': '3', 'cols': '40'}), label='Message', max_length=280)
\end{lstlisting}

When the form is submitted, a post request is sent to the function-based view
seen in code block ~\ref{code:djangoCreateMessageView}. In this view, the following
conditions are checked: whether or not the request type is POST, the validity of the
form, and whether or not the user is authenticated. If these conditions are true,
the message is created and saved to the database. If not, an appropriate error
message is rendered.

\begin{lstlisting}[caption={Function-based create message view},label={code:djangoCreateMessageView}]
	def create_message(request):
		"""
		Create a message for the logged in user

		:param request: The request sent by the user
		:return: Display the profile page with a relevant message
		"""
		if request.method == 'POST':
			form = NewWireForm(request.POST) # Get the form data from the request
			if form.is_valid():
				if request.user.is_authenticated:
					message = form.cleaned_data['message'] # Retrieve the message from the form data
					try:
						Message.objects.create(message_text=message, created=timezone.now(), user=request.user) # Save the message in the database
						messages.success(request, 'Message created successfully', extra_tags='success')
						return HttpResponseRedirect(reverse('wire_profile:current_profile'))
					except DatabaseError:
						messages.error(request, 'Error creating message, please contact support', extra_tags='danger')
						return HttpResponseRedirect(reverse('wire_profile:current_profile'))
				# ... each else condition renders an appropriate error message
\end{lstlisting}

The method to retrieve URL parameters in Django differs depending on the type
of view you use. For class-based views, URL parameter values are retrieved using
the \texttt{kwargs} variable available in all class-based views, as seen in
code block ~\ref{code:djangoSearchMessage}. For function-based views, a
parameter is added to the function itself, as seen in code block ~\ref{code:djangoGetUserIds}. 

\begin{lstlisting}[caption={Function-based view for returning user data},label={code:djangoGetUserIds}]
	def get_user_ids(request, user_ids):
		"""
		Get the users with the given IDs in JSON format

		:param request: The request that called this function
		:param user_ids: The user ids to get the users for
		:return: list of users in JSON format
		"""
		user_ids_list = filter(bool, user_ids.split('/'))
		user_ids_list = list(map(int, user_ids_list))
		% users = User.objects.filter(pk__in=user_ids_list).values('username')
		return JsonResponse(list(users), safe=False)
\end{lstlisting}

\clearpage

\begin{lstlisting}[caption={Class-based view to search for a given message},label={code:djangoSearchMessage}]
	class SearchMessageView(TemplateView):
		template_name = 'wire_profile/search_message.html'

		def get(self, request, *args, **kwargs):
			"""
			Render the matching messages for a search message query

			:param request: The current request
			:param args: sent to parent method
			:param kwargs: sent to parent method
			:return: Render the search message results page
			"""
			query = self.kwargs['query']
			search_results = Message.objects.filter(message_text__icontains=query).all()
			context = self.get_context_data(**kwargs)
			context['search_results'] = search_results
			return self.render_to_response(context)
\end{lstlisting}

\subsection{Templates}
The Django template language can be used in any HTML, CSS, and JavaScript
file. The Django template language can be used to perform variable interpolation,
conditional checks, loops, and creating default blocks of code that can be reused
in other templates. Rendering these files executes the the template logic that the
file contains. \parencite{djangoTemplates}

\newpage

\begin{lstlisting}[caption={Template file for the search page},label={code:djangoSearchTemplate}]
	{% extends "base/global/base.html" %}

	{% load django_bootstrap_breadcrumbs %}
	{% load bootstrap3 %}
	{% load static %}
	
	{% block breadcrumbs %}
		{{ block.super }}
		{% breadcrumb "Search" "wire_profile:search" %}
	{% endblock %}
	
	{% block title %}
		Search
	{% endblock %}
	
	{% block content %}
	<main>
		<div class="container">
			<div class="row">
				<div class="col-sm-12">
					<form id="search-form" class="inline form-horizontal" role=form method=post action="/search">
						{% csrf_token %}
						{% bootstrap_form form %}
					</form>
				</div>
			</div>
		</div>
	</main>
	{% endblock %}
\end{lstlisting}

Code block ~\ref{code:djangoSearchTemplate} contains the source code for the
template file used to render the search page. In this file, a base template
is loaded, which is a full HTML page with the content divided up
into a number of blocks. These blocks are then overridden in the search template
to define breadcrumbs, set the page title, and write the markup for the main
content of the page. Laying out template files like this eliminates repetitive
code and keeps the Django template files similar to their Yesod counterparts,
reducing the need to design different templates in both frameworks.

\subsection{Tests}

Django tests are contained in the \texttt{tests.py} file within an app. Tests
are functions within a class. The process for testing in Django is similar to
Yesod: we create any needed database entities at the beginning of a test,
make a request, and check to see if the response is what we expect. Code
block ~\ref{code:djangoCurrentProfileTest} is a test where a user account
is created, logged in, and then the profile page for the user is loaded.
Django does not have the functionality available in Yesod that allows you
to test the content of a HTML page using CSS selectors, so instead, we test
that the correct template is being loaded with the expected template variables.

\begin{lstlisting}[caption={Django current profile test},label={code:djangoCurrentProfileTest}]
	class CurrentProfileViewTest(TestCase):
		# Other tests...
		def test_current_profile_page_for_logged_in_users(self):
			user = User.objects.create_user('testfoo', 'test@test.com', 'test')
			self.client.post(reverse('base:verify'), {'username': user.username, 'password': 'test'})
			response = self.client.get(reverse('wire_profile:current_profile'))

			self.assertEqual(response.status_code, 200)
			self.assertEqual(response.context['user'], user)
			self.assertIsInstance(response.context['form'], NewWireForm)
			self.assertTemplateUsed(response, 'wire_profile/current_profile.html')
\end{lstlisting}

In Django, we can still examine the content of a response, as seen in code block ~\ref{code:djangoCheckJsonResponse}.
In this block, we make a JSON request, decode the response, and ensure that the response
content contains the expected data.

\begin{lstlisting}[caption={Django checking a JSON response test},label={code:djangoCheckJsonResponse}]
	class GetUserIdsTest(TestCase):
		# Other tests...
		def test_get_user_ids_one_user(self):
			user = User.objects.create_user('foo', 'test@test.com', 'test')
			user2 = User.objects.create_user('bar', 'bar@test.com', 'test')
			user3 = User.objects.create_user('baz', 'baz@test.com', 'test')

			response = self.client.get(reverse('wire_profile:get_user_ids', kwargs={'user_ids': str(user.id) + '/'}))
			response_content = response.content.decode()

			self.assertEqual(response.status_code, 200)
			self.assertIn('"username": "' + user.username + '"', response_content)
			self.assertNotIn('"username": "' + user2.username + '"', response_content)
			self.assertNotIn('"username": "' + user3.username + '"', response_content)
\end{lstlisting}

\section{Comparison of Django and Yesod}

This section consists of a comparison of both frameworks. A series of experiments
were conducted as specified in the plan, the raw results of which can be found
in appendix ~\ref{app:Experiments}. These results will be discussed along with
features and limitations of both frameworks that stand out.

To ensure that the results we collected were as fair as possible, two Amazon
EC2 servers were created. The configuration of both servers were identical,
with them having 1GB of RAM and 1 CPU core available. The tools necessary
to deploy the website were installed on both servers and both sites were
released on the server, allowing testing to begin.

\subsection{Deployment}

Deploying a Yesod onto an Amazon EC2 app is very simple. Yesod has built-in
support for a tool called Keter, a Haskell application that can act as a
web server. After Keter was installed and configured on the Amazon EC2 server,
a Keter binary was created using commands built-in to Yesod. This binary
file can simply be transferred onto the server, and Keter will start serving
the web application to visitors. \parencite[Deploying your Webapp]{yesodBook}

For the Django website, nginx, an open source web server was installed. nginx
acts as a reverse proxy to the Django application, which is being run by a tool
called Gunicorn (`Green Unicorn'). Gunicorn is a WSGI (`Web Server Gateway
Interface') tool that can be used on Unix systems. \parencite{djangoGunicorn} This means that Gunicorn
can allow nginx to use Django to serve the web application.

\subsection{Page Load Speed}
\label{sec:pageLoadSpeed}

When testing page load speeds, each page was loaded three times. The time
taken for each run was recorded as well as an average. In this section,
we will be discussing the average times that were recorded. The raw
results can be found in section ~\ref{sec:pageLoadSpeeds} in the appendix.

Page load speeds for Yesod are noticeably quicker than Django, with Yesod
loading most pages around 200ms faster. For example, on average, the home page
takes about 511ms to load in the Yesod framework, and 750ms to load in the
Django framework. Creating a new message and then redirecting back to the
profile page takes about 679ms in Yesod and 849ms in Django. See
table ~\ref{tab:pageLoadAverageSpeeds} for a full list of results.

\begin{table}[H]
	\caption{Average Page Load Speeds}
	\begin{center}
		\begin{tabular}{ | l | r | r |}
			\hline
			Page & Average Speed in Yesod (ms) & Average Speed in Django (ms) \\
			\hline
			Home Page & 511.00 & 753.33 \\
			Search Page & 517.33 & 756.33 \\
			Login Page & 443.67 & 821.33 \\
			Signup Page & 490.33 & 764.00 \\
			Creating an Account & 504.33 & 748.67 \\
			Logging in to an Account & 547.33 & 722.67 \\
			Logging out & 510.33 & 761.33 \\
			Current user's Profile Page & 617.00 & 930.00 \\
			Other user's Profile Page & 651.33 & 908.67 \\
			Creating a Message & 679.33 & 848.67 \\
			Search for a Message & 513.33 & 766.33 \\
			Search for a User & 519.00 & 756.67 \\
			\hline
		\end{tabular}
	\end{center}
	\label{tab:pageLoadAverageSpeeds}
\end{table}

As you can see in table in table ~\ref{tab:pageLoadAverageSpeeds}, Yesod
consistently outperforms Django. This could be for a number of reasons:
Yesod automatically minimises static files like CSS or JavaScript;
Haskell is compiled rather than interpreted, and compiled code generally
runs faster than interpreted code; the lazy evaluation of Haskell may
give some speed improvements; and the Keter tool used on the server
is made specifically for Haskell web applications, which may mean that
Yesod and Keter will run faster than Django and nginx.

\subsection{Load Tests}

Load tests were conducting using a tool called RedLine13. RedLine13 is
a service that allows users to perform load testing using Amazon EC2
servers. With RedLine13, I was able to send requests from an Amazon
EC2 server to the Yesod and Django websites. To keep within the
usage limits of RedLine13 and Amazon EC2, three load tests were
conducted. Each test had 80 users load a specific page in a short
amount of time, typically 25 seconds. The results of these tests can
be found in table ~\ref{tab:loadTests}.

\begin{table}[H]
	\caption{Load Testing Page Load Speeds}
	\begin{center}
		\begin{tabular}{ | l | l | l |}
			\hline
			Page & Yesod (s) & Django (s) \\
			\hline
			Home & 4.96 & 5.54 \\
			Profile 1st Run & 5.05 & 4.94 \\
			Profile 2nd Run & 4.97 & 5.13 \\
			Average & 4.99 & 5.20 \\
			\hline
		\end{tabular}
	\end{center}
	\label{tab:loadTests}
\end{table}

As you can see in the table above, Yesod is around 200-500ms faster than
Django when under load. This difference is consistent with the results
found in section ~\ref{sec:pageLoadSpeed}. The high loading times
seen in these tests is probably because the servers are being are not
very powerful.

The tests also recorded the total amount of data downloaded for all
users. Yesod beat Django by a sizeable margin in this test, with
Yesod sending, on average, 6.46MB of data per test and Yesod
sending 18.19MB of data. This is because Yesod, by default, compresses
all static files. If we load the home page of both websites, Yesod
transfers 76.83kB of data which is decompressed to 246.57kB being stored
on the disk. Django, on the other hand, transfers 243.49kB of data.

\subsection{Resource Usage}

Resource usage on both servers was measured after running the experiments
detailed in section ~\ref{sec:pageLoadSpeed}. All the information in 
this section was obtained by examining output from htop, a process viewer. 
On the server running Yesod, 109MB of RAM was being used. The server running 
Django used 125MB of RAM.

To run a web server on the Yesod server, Keter creates two sub-processes.
One of these sub-processes loads the compiled code for the website, and the
other loads the configuration file for the web server. Altogether, these
three processes use about 83MB of RAM in total, with 56MB of RAM being
shared.

On the Django server, gunicorn, when executed with the default settings, creates
one sub-process. These two processes use around 65MB of RAM and share 19MB
of RAM. nginx is not very memory intensive, using 6MB of RAM, sharing 3MB.
In total, the Django server uses 71M of RAM, sharing 22MB.

Yesod is ahead of Django when it comes to resource usage. Even though all the
Keter processes use more memory than gunicorn, most of the memory used by Keter
is shared, resulting in the overall memory usage in the Yesod server being lower
than the Django server. The RAM usage of the Django server is 16MB more than
the Yesod server, but this difference is negligible considering the resources
available to most servers at this time.

\subsection{Continuous Integration}

For the duration of this project, all programming has been done on a git
repository stored on GitHub. Travis CI, a continuous integration tool,
syncs with GitHub in order to run tests on the repository every time
there is a new commit. The way this works is that every time a commit
is pushed to GitHub, GitHub sends the details of the commit to something
called a Webhook. Travis gets an update from this Webhook, and executes
a file called \texttt{.travis.yml} placed in the root of the repository.
This file contains instructions telling Travis how to run the tests
on the codebase.

Yesod did take longer to run tests when compared to Django. The Django
repository took around 2.5 minutes to build and run all the tests. Yesod
took around 3.5-4 minutes. For continuous integration, this difference
is negligible as any code will be peer reviewed in a real life before being
merged in to the main branch. For developing however, Django does speed
things along when you're implementing a new feature in a test driven way
and are running the test suite multiple times to ensure your feature
works and does not unintentionally break other features.

\subsection{Debugging}

When developing, you sometimes make mistakes. When you make these mistakes,
ideally, you would want to see an error message that tells you where you
made the mistake and some information about the error itself which may
help you resolve this mistake. As part of evaluating Yesod and Django,
simulated mistakes were made in both frameworks.

The first simulated mistake we made was, when creating a message, try
to save the form data object into the database rather than the actual
message stored inside this object. The code change in Yesod can be
seen in code block ~\ref{code:yesodMessageT1L}, and the Django change can
be seen in code block ~\ref{code:djangoMessageT1L}.


\lstset{language={Haskell}}
\begin{lstlisting}[caption={Yesod Code Change},label={code:yesodMessageT1L}]
	(Entity userId _) <- requireAuth -- get the user id
	((result, _), _) <- runFormPost $ messageForm userId -- get the form data
	case result of
		FormSuccess message -> do -- if it's a valid form, get the message
			-- _ <- runDB . insert $ message -- original line, insert message
			_ <- runDB . insert $ result -- new line, insert form data
\end{lstlisting}

\clearpage

\lstset{language={Python}}
\begin{lstlisting}[caption={Django Code Change},label={code:djangoMessageT1L}]
	form = NewWireForm(request.POST) -- get the form
	if form.is_valid():
		if request.user.is_authenticated:
			message = form.cleaned_data['message'] -- form.cleaned_data is a map of form values
			try:
				# Message.objects.create(message_text=message, ..) # original line, store the message
				Message.objects.create(message_text=form.cleaned_data, ..) # changed line 1, store form values
				# Message.objects.create(message_text=form, ..) # changed line 2, after previous line passed, store form object
\end{lstlisting}

For Yesod, the simulated error caused a compilation error, with the exception
message complaining about mismatched types, as seen in code block ~\ref{code:yesodT1E}. 
For Django, however, no exception was thrown, even when submitting the message. 
Further investigation showed that Python was converting the form data into a
string, and then saved this string in the database. Because the message was saved 
in the database, the tests, which at the time only checked the amount of objects
in the message table, passed. This test was later amended to check the actual
content of the message, and failed appropriately when the mistake was reintroduced.

\lstset{language={Haskell}}
\begin{lstlisting}[caption={Yesod Exception Message},label={code:yesodT1E}]
	- Couldn't match type `PersistEntityBackend (FormResult Message)'
	with `SqlBackend'
	arising from a use of `insert'
	- In the second argument of `(.)', namely `insert'
	In the expression: runDB . insert
	In a stmt of a 'do' block: _ <- runDB . insert $ result
\end{lstlisting}

In the second test, we simply misspelled a variable name. This would normally
be caught by most editors but it would be useful to see the error message produced
as a result of a particularly common mistake. This mistake was done in the piece
of code that returns data for recommended users in JSON format. This is used
as part of an AJAX request to display recommended users to the user on the
profile page. See code block ~\ref{code:yesodVarT2} for the Yesod change and
code block ~\ref{code:djangoVarT2} for the Django change.

\lstset{language={Haskell}}
\begin{lstlisting}[caption={Yesod Code Change},label={code:yesodVarT2}]
	Entity userId user <- requireAuth
	followers <- runDB $ selectList [FollowFollowerId ==. userId] []
	-- See: https://stackoverflow.com/questions/36727794/haskell-persistent-reusing-selectlist
	let followingIds = map (\(Entity _ (Follow _ followingId)) -> followingId) followers
	users <- runDB $ selectList [UserUsername !=. userUsername user, UserId /<-. followingIds] [LimitTo 5]
	let cleanUsers = map (\(Entity uid (User uname _ _)) -> (object ["id" .= uid, "username" .= uname])) users
	-- returnJson cleanUsers -- original line
	returnJson cleanUser -- new line
\end{lstlisting}

\lstset{language={Python}}
\begin{lstlisting}[caption={Django Code Change},label={code:djangoVarT2}]
	if request.user.is_authenticated:
	follow_query = Follow.objects.filter(follower_id=request.user)
	users = User.objects.filter().exclude(id=request.user.id).exclude(username=excluded_username)\
		.exclude(followed_user__in=follow_query).values('username')[:5]
	# return JsonResponse(list(users), safe=False)  # original line
	return JsonResponse(list(user), safe=False)  # new line
\end{lstlisting}

The change caused a compilation error in Yesod. The exception message complained
about the misspelled variable not being in scoped, and actually recommended the
correct variable that should have been used.
For Django, the recommended users section did not load in the Profile page.
Checking the network tab of the web developer tool built into the browser
showed that the AJAX request responded with a 500 error. Loading the URL used
in the AJAX request displayed an exception, with a stack trace and a message that said 
``name `user' is not defined''.

\lstset{language={Haskell}}
\begin{lstlisting}[caption={Yesod Exception Message},label={code:yesodT2E}]
	Variable not in scope: cleanUser
	Perhaps you meant `cleanUsers' (line 19)
\end{lstlisting}

\subsection{Documentation}

The book, \citetitle{yesodBook}, will teach you almost all the features of the
Yesod framework. The book has a lot of detail of how every feature in Yesod works,
including templates, database entities, routing, and deployment. If the reader
is familiar with Haskell, the book will give you the base knowledge needed
in order to start developing a Yesod website.

The problem with Yesod is that outside of topics in the book, the documentation
of libraries used is, most of the time, not very detailed. Most of the documentation
for these libraries are a couple of lines explaining what a function does and
a Haskell type signature. For more experienced Haskell programmers, most of the
time, this is all you need to figure out how to use a function. You can also
examine the source code if you need more information on how a function works.
However, for developers who are new to Haskell, examples and detailed explanations
like the one given in the book are invaluable. This resulted in a lot of time
being spent towards the beginning of the project trying to fix errors that would be
trivial for more experienced developers. As the project progressed further, the 
documentation and type signatures provided by external libraries became easier to 
understand as knowledge of Haskell increased.

The Django project also has excellent documentation. There are tutorials for
beginners to get started with Yesod, tutorials for deploying Django websites,
and documentation on almost all functions in the framework. Most of the
documentation also contain usage examples which are invaluable for
beginners who want to easily see how a function works. This is a definite
advantage that Django has over Yesod. The Yesod book does have great
usage examples but the documentation for external libraries is lacking.

\subsection{Community}

Django has millions of users. This means that any issue you come across,
someone else has most likely already encountered and solved. This means that
a lot of the time, when you come across an issue, you can just search for
the error message and come across forum posts discussing solutions
for the exact same error that you are having.

Yesod, on the other hand, has a much smaller community. It is likely that
you are the only person experiencing a certain issue. This
was certainly the case for when Freckle migrated to Yesod, as discussing in
chapter ~\ref{chap:Background}. Because of this, beginners will likely find it
harder to solve issues with Yesod when compared to Django.

Although the Haskell community is small, experienced developers are almost always
available to help beginners with issues if they make a post on an appropriate
forum. In fact, with Yesod, you often see Michael Snoyman, the person who wrote
the framework, answering questions posted by beginners. Developers can also
join the \#haskell-beginners IRC channel where they can speak to an experienced
developer about their issues in real time.

\subsection{Recommendations}

After running all of our tests, we can see that a relatively niche framework
like Yesod can keep up with a giant like Django. If you're an experienced
Haskell developer and are looking for a web framework to use for your project,
then Yesod is a great choice. The documentation for Yesod itself is excellent,
it is being used in the real world on websites that get millions of visitors,
and the community is great when you are experiencing an issue.

Performance-wise Yesod is faster and less resource intensive than Django. This
is most likely because of the fact that Haskell is a compiled language, and
compiled languages are generally faster than interpreted languages, like Python.
If your primary concern when it comes to choosing a web framework is performance,
then Yesod is a great choice.

For Haskell beginners or people who have no experience in Haskell, you should
only decide to use Yesod if you are willing to dedicate a lot of time to learn
Haskell and the framework itself. Yesod is a nice framework to use if you're
an experienced Haskell developer, but it can be frustrating for beginners. You will
find it hard to understand why your code won't compile, some of the documentation
of external libraries is poor, and you will not understand how a lot of the
advanced Haskell features being used in Yesod work. If you need to find a web
framework to start working on right away, then Yesod is not for you. If you are
willing to learn Haskell and the framework itself, then Yesod is a great choice. 
The Haskell community is friendly towards
beginners and will be willing to help you if you are experiencing issues, and
developing a Yesod application is a great way to develop your Haskell knowledge.

As shown in the tests where we simulated common development errors, Yesod
is very robust. It will not compile at all if there is a mismatched type,
saving you from having to write tests to detect when a mismatched type
occurs. Because Python uses type coercion, Django is more flexible in
this regard. This may save time when developing but it may cause unexpected
errors as seen in our tests. This is a matter of personal preference, some
developers will prefer the flexibility that Python's dynamic types give
you, and others will prefer the robustness of Haskell's static types
and type safety.

In conclusion, Yesod is a production ready framework. It is used in the real
world, can keep up and sometimes outperform other popular frameworks,
has great documentation, and has a helpful community.
